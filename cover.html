
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>generate: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kubeflow/katib/pkg/cert/v1beta1/generate/generate.go (59.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2021 The Kubeflow Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generate

import (
        "bytes"
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/json"
        "encoding/pem"
        "errors"
        "fmt"
        "github.com/kubeflow/katib/pkg/cert/v1beta1/common"
        "github.com/spf13/cobra"
        certificatesv1 "k8s.io/api/certificates/v1"
        certificatesv1beta1 "k8s.io/api/certificates/v1beta1"
        corev1 "k8s.io/api/core/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/klog"
        "k8s.io/utils/pointer"
        "os"
        "path"
        "strings"
        "time"
)

type generateOptions struct {
        namespace string
        fullServiceDomain string
        csrName string
        csrAPIVersion string
        caBundleDir string
        kubeClient kubernetes.Interface
}

func NewGenerateCmd(kubeClient kubernetes.Interface) *cobra.Command <span class="cov0" title="0">{
        o := &amp;generateOptions{
                caBundleDir: "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt",
        }
        cmd := &amp;cobra.Command{
                Use:   "generate",
                Short: "generate server cert for webhook",
                Long: "generate server cert for webhook",
                SilenceUsage: true,
                RunE: func(cmd *cobra.Command, args []string) error</span><span class="cov0" title="0">{
                        ctx := context.TODO()
                        config, err := rest.InClusterConfig()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">o.kubeClient, _ = kubernetes.NewForConfig(config)
                        if err := o.run(ctx); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }
        <span class="cov0" title="0">f := cmd.Flags()
        f.StringVarP(&amp;o.namespace, "namespace", "n", "kubeflow", "set namespace")
        return cmd</span>
}

type keyPair struct {
        cert []byte
        key []byte
}
func (o *generateOptions) run (ctx context.Context) error <span class="cov0" title="0">{
        certs, err := o.requestServerCert(ctx, o.kubeClient.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return o.injectCert(ctx, certs)</span>
}

func (o *generateOptions) requestServerCert (ctx context.Context, discovery discovery.DiscoveryInterface) (*keyPair, error) <span class="cov8" title="1">{
        o.fullServiceDomain = strings.Join([]string{common.Service, o.namespace, "svc"}, ".")
        o.csrName = strings.Join([]string{common.Service, o.namespace}, ".")
        versions := &amp;common.ServerVersion{}
        if err := versions.NewServerVersion(discovery); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := o.getCSRAPIVersion(*versions); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">certs, err := o.createCSR()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return certs, o.createKubeCSR(ctx, certs, versions)</span>
}

func (o *generateOptions) injectCert(ctx context.Context, certs *keyPair) error <span class="cov8" title="1">{
        if err := o.getServerCert(ctx, certs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := o.createWebhookCertSecret(ctx, certs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return o.patchWebhookConfiguration(ctx)</span>
}

// getCSRAPIVersion will return 'v1' or 'v1beta1'
func (o *generateOptions) getCSRAPIVersion(versions common.ServerVersion) error <span class="cov8" title="1">{
        if versions.Major == 1 &amp;&amp; versions.Minor &gt; 18 </span><span class="cov8" title="1">{
                o.csrAPIVersion = "v1"
        }</span> else<span class="cov8" title="1"> {
                o.csrAPIVersion = "v1beta1"
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// createCSR will return x509 CertificateRequest and private key
func (o *generateOptions) createCSR() (*keyPair, error) <span class="cov8" title="1">{
        template := &amp;x509.CertificateRequest{
                Subject: pkix.Name{
                        CommonName: strings.Join([]string{
                                "system",
                                "node",
                                o.fullServiceDomain,
                        }, ":"),
                        Organization: []string{"system:nodes"},
                },
                DNSNames: []string{
                        common.Service,
                        o.csrName,
                        o.fullServiceDomain,
                },
                SignatureAlgorithm: x509.SHA256WithRSA,
        }

        rawKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">encodedKey := &amp;bytes.Buffer{}
        if err := pem.Encode(encodedKey, &amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(rawKey)}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rawCert, err := x509.CreateCertificateRequest(rand.Reader, template, rawKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">encodedCert := &amp;bytes.Buffer{}
        if err = pem.Encode(encodedCert, &amp;pem.Block{Type: "CERTIFICATE REQUEST", Bytes: rawCert}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;keyPair{
                encodedCert.Bytes(),
                encodedKey.Bytes(),
        }, nil</span>
}

// NOTE: certificates.k8s.io/v1 is not supported in Kubernetes &lt; 1.19 and certificates.k8s.io/v1beta1 removed in 1.22.
// createCSR create certificates.k8s.io CertificateSigningRequest.
func (o *generateOptions) createKubeCSR(ctx context.Context, certs *keyPair, versions *common.ServerVersion) error <span class="cov8" title="1">{

        switch o.csrAPIVersion </span>{
        case "v1":<span class="cov8" title="1"> // certificates.k8s.io/v1

                _, err := o.kubeClient.CertificatesV1().CertificateSigningRequests().Get(ctx, o.csrName, metav1.GetOptions{})
                switch </span>{
                case err != nil &amp;&amp; !k8serrors.IsNotFound(err):<span class="cov0" title="0">
                        return err</span>
                case err == nil:<span class="cov0" title="0">
                        klog.Warning("Previous CSR was found and removed.")
                        if err = o.kubeClient.CertificatesV1().CertificateSigningRequests().Delete(ctx, o.csrName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">kubeCSRv1 := &amp;certificatesv1.CertificateSigningRequest{
                        TypeMeta: metav1.TypeMeta{
                                Kind: "CertificateSigningRequest",
                                APIVersion: path.Join("certificates.k8s.io", o.csrAPIVersion),
                        },
                        ObjectMeta: metav1.ObjectMeta{
                                Name: o.csrName,
                        },
                        Spec: certificatesv1.CertificateSigningRequestSpec{
                                Groups: []string{
                                        "system:authenticated",
                                },
                                Request: certs.cert,
                                SignerName: "kubernetes.io/kubelet-serving",
                                Usages: []certificatesv1.KeyUsage{
                                        "digital signature",
                                        "key encipherment",
                                        "server auth",
                                },
                        },
                }

                klog.Infof("Creating CSR: %s", o.csrName)
                if _, err = o.kubeClient.CertificatesV1().CertificateSigningRequests().Create(ctx, kubeCSRv1, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">kubeCSRv1.Status.Conditions = append(kubeCSRv1.Status.Conditions,
                        certificatesv1.CertificateSigningRequestCondition{
                                Type:           certificatesv1.CertificateApproved,
                                Status:         corev1.ConditionTrue,
                                Reason:         common.ApproveReason,
                                Message:        common.ApproveMessage,
                                LastUpdateTime: metav1.Now(),
                        },
                )
                if _, err = o.kubeClient.CertificatesV1().CertificateSigningRequests().UpdateApproval(ctx, o.csrName, kubeCSRv1, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case "v1beta1":<span class="cov8" title="1"> // certificates.k8s.io/v1beta1
                _, err := o.kubeClient.CertificatesV1beta1().CertificateSigningRequests().Get(ctx, o.csrName, metav1.GetOptions{})
                switch </span>{
                case err != nil &amp;&amp; !k8serrors.IsNotFound(err):<span class="cov0" title="0">
                        return err</span>
                case err == nil:<span class="cov0" title="0">
                        klog.Warning("Previous CSR was found and removed.")
                        if err = o.kubeClient.CertificatesV1beta1().CertificateSigningRequests().Delete(ctx, o.csrName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">kubeCSRv1beta1 := &amp;certificatesv1beta1.CertificateSigningRequest{
                        TypeMeta: metav1.TypeMeta{
                                Kind: "CertificateSigningRequest",
                                APIVersion: path.Join("certificates.k8s.io", o.csrAPIVersion),
                        },
                        ObjectMeta: metav1.ObjectMeta{
                                Name: o.csrName,
                        },
                        Spec: certificatesv1beta1.CertificateSigningRequestSpec{
                                Groups: []string{
                                        "system:authenticated",
                                },
                                Request: certs.cert,
                                Usages: []certificatesv1beta1.KeyUsage{
                                        "digital signature",
                                        "key encipherment",
                                        "server auth",
                                },
                        },
                }

                // signerName is not supported in Kubernetes &lt;= 1.17
                // See: https://github.com/kubeflow/katib/issues/1500
                if versions.Major == 1 &amp;&amp; versions.Minor &gt;= 18 </span><span class="cov8" title="1">{
                        kubeCSRv1beta1.Spec.SignerName = pointer.String(common.SignerName)
                }</span>

                <span class="cov8" title="1">if _, err = o.kubeClient.CertificatesV1beta1().CertificateSigningRequests().Create(ctx, kubeCSRv1beta1, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">kubeCSRv1beta1.Status.Conditions = append(kubeCSRv1beta1.Status.Conditions,
                        certificatesv1beta1.CertificateSigningRequestCondition{
                                Type:           certificatesv1beta1.CertificateApproved,
                                Status:         corev1.ConditionTrue,
                                Reason:         common.ApproveReason,
                                Message:        common.ApproveMessage,
                                LastUpdateTime: metav1.Now(),
                        },
                )
                if _, err = o.kubeClient.CertificatesV1beta1().CertificateSigningRequests().UpdateApproval(ctx, kubeCSRv1beta1, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (o *generateOptions) getServerCert(ctx context.Context, certs *keyPair) error <span class="cov8" title="1">{
        errorMessage := fmt.Sprintf(
                "After approving csr %s, the signed certificate did not appear on the resource. Giving up after 1 minute.",
                o.csrName,
        )
        switch o.csrAPIVersion </span>{
        case "v1":<span class="cov8" title="1"> // certificates.k8s.io/v1

                createdCSRv1 := &amp;certificatesv1.CertificateSigningRequest{}
                for i:=0; i&lt;=20; i++ </span><span class="cov8" title="1">{
                        var err error
                        createdCSRv1, err = o.kubeClient.CertificatesV1().CertificateSigningRequests().Get(ctx, o.csrName, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">switch </span>{
                        case !bytes.Equal(createdCSRv1.Status.Certificate, nil):<span class="cov8" title="1">
                                break</span>
                        case i == 20:<span class="cov0" title="0">
                                return errors.New(errorMessage)</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(time.Second * 3)</span>
                        }
                }
                <span class="cov8" title="1">certs.cert = createdCSRv1.Status.Certificate</span>

        case "v1beta1":<span class="cov8" title="1"> // certificates.k8s.io/v1beta1

                createdCSRv1beta1 := &amp;certificatesv1beta1.CertificateSigningRequest{}
                for i:=0; i&lt;=20; i++ </span><span class="cov8" title="1">{
                        var err error
                        createdCSRv1beta1, err = o.kubeClient.CertificatesV1beta1().CertificateSigningRequests().Get(ctx, o.csrName, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">switch </span>{
                        case !bytes.Equal(createdCSRv1beta1.Status.Certificate, nil):<span class="cov8" title="1">
                                break</span>
                        case i == 20:<span class="cov0" title="0">
                                return errors.New(errorMessage)</span>
                        default:<span class="cov0" title="0">
                                time.Sleep(time.Second * 3)</span>
                        }
                }
                <span class="cov8" title="1">certs.cert = createdCSRv1beta1.Status.Certificate</span>

        }

        <span class="cov8" title="1">return nil</span>
}

// createWebhookCertSecret create Secret embedded tls.key and tls.cert
func (o *generateOptions) createWebhookCertSecret(ctx context.Context, certs *keyPair) error <span class="cov8" title="1">{

        certGeneratorJob, err := o.kubeClient.BatchV1().Jobs(o.namespace).Get(ctx, common.JobName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">jobUID := certGeneratorJob.UID
        certSecret := &amp;corev1.Secret{
                TypeMeta: metav1.TypeMeta{
                        Kind: "Secret",
                        APIVersion: "v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      common.Secret,
                        Namespace: o.namespace,
                        OwnerReferences: []metav1.OwnerReference{
                                {
                                        APIVersion: "batch/v1",
                                        Kind:       "Job",
                                        Controller: pointer.BoolPtr(true),
                                        Name:       common.JobName,
                                        UID:        jobUID,
                                },
                        },
                },
                Type: corev1.SecretTypeTLS,
                Data: map[string][]byte{
                        "tls.key": certs.key,
                        "tls.crt": certs.cert,
                },
        }

        _, err = o.kubeClient.CoreV1().Secrets(o.namespace).Get(ctx, common.Secret, metav1.GetOptions{})
        switch </span>{
        case err != nil &amp;&amp; !k8serrors.IsNotFound(err):<span class="cov0" title="0">
                return err</span>
        case err == nil:<span class="cov0" title="0">
                klog.Warning("Previous secret was found and removed.")
                if err = o.kubeClient.CoreV1().Secrets(o.namespace).Delete(ctx, common.Secret, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">klog.Infof("Creating Secret: %s", common.Secret)
        if _, err = o.kubeClient.CoreV1().Secrets(o.namespace).Create(ctx, certSecret, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type jsonPatch struct {
        Op string `json:"op"`
        Path string `json:"path"`
        Value []byte `json:"value"`
}

// patchWebhookConfiguration apply patch to ValidatingWebhookConfiguration and MutatingWebhookConfiguration
func (o *generateOptions) patchWebhookConfiguration(ctx context.Context) error <span class="cov8" title="1">{
        caBundle, err := os.ReadFile(o.caBundleDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">validatingWebhookConfigurationPatch := []jsonPatch{
                {
                        Op: "replace",
                        Path: "/webhooks/0/clientConfig/caBundle",
                        Value: caBundle,
                },
        }
        validatingWebhookConfigurationPatchBytes, err := json.Marshal(validatingWebhookConfigurationPatch)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">mutatingWebhookConfigurationPatch := []jsonPatch{
                {
                        Op: "replace",
                        Path: "/webhooks/0/clientConfig/caBundle",
                        Value: caBundle,
                },
                {
                        Op: "replace",
                        Path: "/webhooks/1/clientConfig/caBundle",
                        Value: caBundle,
                },
        }
        mutatingWebhookConfigurationPatchBytes, err := json.Marshal(mutatingWebhookConfigurationPatch)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">klog.Info("Trying to patch ValidatingWebhookConfiguration adding the caBundle.")
        _, err = o.kubeClient.
                AdmissionregistrationV1().
                ValidatingWebhookConfigurations().
                Patch(ctx, common.Webhook, types.JSONPatchType, validatingWebhookConfigurationPatchBytes, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Unable to patch ValidatingWebhookConfiguration %s", common.Webhook)
                return err
        }</span>

        <span class="cov8" title="1">klog.Info("Trying to patch MutatingWebhookConfiguration adding the caBundle.")
        _, err = o.kubeClient.
                AdmissionregistrationV1().
                MutatingWebhookConfigurations().
                Patch(ctx, common.Webhook, types.JSONPatchType, mutatingWebhookConfigurationPatchBytes, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Unable to patch MutatingWebhookConfiguration %s", common.Webhook)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
